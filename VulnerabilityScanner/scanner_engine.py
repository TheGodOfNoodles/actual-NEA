"""Mock scanning engine for the NEA Web Vulnerability Scanner.

This module provides a simulated implementation of the scanning workflow so
that the CustomTkinter UI can be developed and tested without any real
network activity. The interface mirrors what a future, real scanner could
look like: a single entry point that accepts callbacks for progress/status
updates and returns a list of discovered vulnerabilities.
"""

from __future__ import annotations

import random
import time
from typing import Callable, Dict, List

Vulnerability = Dict[str, str]
ProgressCallback = Callable[[float], None]
StatusCallback = Callable[[str], None]


def _safe_callback(callback: Callable, *args, **kwargs) -> None:
    """Invoke the callback and swallow any exception raised from the UI side."""
    if not callable(callback):
        return
    try:
        callback(*args, **kwargs)
    except Exception:
        # The UI should handle its own logging; silently ignore here to avoid
        # crashing the worker thread.
        pass


def run_full_scan(
    target_url: str,
    depth: int,
    progress_callback: ProgressCallback,
    status_callback: StatusCallback,
) -> List[Vulnerability]:
    """Simulate a vulnerability scan and return mock findings.

    Args:
        target_url: The URL provided by the user.
        depth: Maximum crawl depth (currently unused, kept for parity with a real engine).
        progress_callback: Callable receiving a float between 0.0 and 1.0.
        status_callback: Callable receiving human-readable status strings.
    """

    _safe_callback(status_callback, "Starting scan...")
    time.sleep(0.4)

    _safe_callback(status_callback, "Crawling website...")
    time.sleep(1.0 + min(depth, 3) * 0.3)

    _safe_callback(status_callback, "Testing for XSS...")
    _safe_callback(progress_callback, 0.3)
    time.sleep(1.0)

    _safe_callback(status_callback, "Testing for SQL Injection...")
    _safe_callback(progress_callback, 0.6)
    time.sleep(1.0)

    _safe_callback(status_callback, "Checking security headers...")
    _safe_callback(progress_callback, 0.85)
    time.sleep(0.8)

    findings = _generate_mock_findings(target_url)

    _safe_callback(progress_callback, 1.0)
    final_status = "Scan complete! No issues found." if not findings else "Scan complete!"
    _safe_callback(status_callback, final_status)

    return findings


def _generate_mock_findings(target_url: str) -> List[Vulnerability]:
    """Return deterministic mock findings seeded from the target URL."""
    seed = sum(ord(ch) for ch in target_url) % 1000
    random.seed(seed)

    sample_findings: List[Vulnerability] = [
        {
            "type": "SQL Injection",
            "severity": "High",
            "url": f"{target_url.rstrip('/')}/login",
            "description": "This could allow an attacker to access your database.",
            "recommendation": "Use parameterized queries and sanitize all inputs.",
        },
        {
            "type": "Cross-Site Scripting (XSS)",
            "severity": "Medium",
            "url": f"{target_url.rstrip('/')}/search?q=<script>alert(1)</script>",
            "description": (
                "This allows attackers to run malicious scripts in users' browsers."
            ),
            "recommendation": "Ensure all user input is encoded before rendering.",
        },
        {
            "type": "Missing Security Header",
            "severity": "Low",
            "url": target_url,
            "description": "The Content-Security-Policy header is not present.",
            "recommendation": "Define a CSP header to limit allowed content sources.",
        },
    ]

    # Return a subset to keep results feeling varied.
    number_of_findings = random.choice([0, 1, 2, 3])
    return sample_findings[:number_of_findings]
